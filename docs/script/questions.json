[
    {
        "question": "Beta-riducendo (λn.λm.λf.λx.(nf)((mf)x))(λf.λx.ffffx)(λf.λx.fx) si ottiene",
        "optionA": "λf.λx.ffffx",
        "optionB": "f",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "λf.λx.ffffffx",
        "optionE": "x",
        "optionF": "λf.λx.fffffx",
        "correct": "optionF"
    },
    {
        "question": "<div class='code'>  p = malloc(); <br> q = malloc(); <br> *p = 999 <br> *q = 111 <br> *p += *q <br> q = p <br> free(p) </div><br> Utilizzando la tecnica dei tombstones cosa succede alla fine del frammento di codice dato?",
        "optionA": "*p = 1110 e *q = 111",
        "optionB": "p è deallocato e q punta ad una tombstone",
        "optionC": "p e q sono entrambi deallocati",
        "optionD": "q è deallocato e p punta ad una tombstone",
        "optionE": "*p = 999 e *q = 111",
        "optionF": "*p = 1110 e *q = 1110",
        "correct": "optionB"
    },
    {
        "question": "<div class='code'>  p = malloc(); <br> q = malloc(); <br> *p = 999 <br> *q = 111 <br> *p += *q <br> q = p <br> free(p) </div><br> Utilizzando la tecnica dei tombstones cosa succede alla fine del frammento di codice dato?",
        "optionA": "*p = 1110 e *q = 111",
        "optionB": "*p = 1110 e *q = 1110",
        "optionC": "p e q sono entrambi deallocati",
        "optionD": "q è deallocato e p punta ad una tombstone",
        "optionE": "*p = 999 e *q = 111",
        "optionF": "Nessuna delle risposte",
        "correct": "optionF"
    },
    {
        "question": "<div class='code'>  p = malloc(); <br> q = malloc(); <br> *p = 123 <br> *q = 321 <br> p = q <br> free(q) </div><br> Utilizzando la tecnica dei tombstones cosa succede alla fine del frammento di codice dato?",
        "optionA": "*p = 123 e *q = 321",
        "optionB": "p è deallocato e q punta ad una tombstone",
        "optionC": "p e q sono entrambi deallocati",
        "optionD": "q è deallocato e p punta ad una tombstone",
        "optionE": "*p = 321 e *q = 321",
        "optionF": "Nessuna delle risposte",
        "correct": "optionD"
    },
    {
        "question": "La ricorsione in coda",
        "optionA": "Non è implementabile nei linguaggi imperativi",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Richiede di non scrivere mai la chiamata ricorsiva come ultimo statement di una subroutine",
        "optionD": "Richiede di non ritornare mai direttamente il valore ritornato da una chiamata ricorsiva",
        "optionE": "Permette di risolvere il problema della ricorsione infinita",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Call by constant",
        "optionA": "Fa una copia della variabile",
        "optionB": "è utile per passare oggetti",
        "optionC": "Ritorna il valore al chiamante",
        "optionD": "Permette la modifica della variabile",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Se gli array sono memorizzati per righe e int a[100][100] è un array multidimensionale di interi (si assuma che la dimensione di un intero sia 4 byte) con a[0][0] che ha indirizzo 0x5000, qual è l'indirizzo di a [5][10]?",
        "optionA": "0x57F8",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "0x53ED",
        "optionD": "0x5510",
        "optionE": "0x51FE",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta-riducendo (λn.λm.λf.λx.(nf)((mf)x))(λf.λx.fx)(λf.λx.x) si ottiene",
        "optionA": "λf.λx.f(f(f(fx)))",
        "optionB": "λf.λx.fx",
        "optionC": "x",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "fx",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "I record di attivazione",
        "optionA": "Sono necessari solo in presenza di funzioni di ordine superiore",
        "optionB": "Sono allocati dinamicamente solo in caso di scope dinamico",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Devono essere esplicitamente allocati e deallocati dal codice del programma che li usa",
        "optionE": "Sono allocati solo nello heap",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Si può dire che una macchina astratta che capisce il linguaggio C non sia implementata in modo puramente compilativo perché",
        "optionA": "Gli eseguibili generati da un compilatore C in genere non eseguono direttamente sulla macchina hardware, ma su una macchina astratta che include il runtime del linguaggio e le funzionalità del Sistema Operativo",
        "optionB": "Gli eseguibili generati dal compilatore vengono comunque interpretati da una macchina virtuale",
        "optionC": "Una macchina astratta che capisca un linguaggio di alto livello come il C non è mai implementabile con un compilatore",
        "optionD": "Il runtime del linguaggio C è comunque sempre interpretato",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Il costrutto for dei linguaggi C, C++ e Java",
        "optionA": "Non è un costrutto di iterazione determinata",
        "optionB": "È necessario a tali linguaggi per implementare qualsiasi tipo di algoritmo",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "È un costrutto di iterazione determinata",
        "optionE": "Permette di sapere in anticipo quante volte il ciclo verrà ripetuto (indipendentemente dal corpo del ciclo)",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Un'entità esprimibile è",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Un'entità che può essere generata come risultato da un'espressione complessa o da una funzione",
        "optionC": "Un'entità che ancora non compare nell'ambiente",
        "optionD": "Un'entità che può essere memorizzata",
        "optionE": "Una generica entità a cui può essere dato un nome",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In assenza di ambiente non locale",
        "optionA": "Per implementare funzioni definite ricorsivamente è necessario utilizzare un fixed point combinator",
        "optionB": "Non si possono implementare algoritmi ricorsivi",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Non si possono implementare algoritmi iterativi o ricorsivi",
        "optionE": "Non si possono implementare algoritmi iterativi",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "I puntatori di catena dinamica contenuti in un record di attivazione",
        "optionA": "Collegano una lista di zone di memoria gestita dinamicamente",
        "optionB": "Servono per accedere alle variabili dinamiche",
        "optionC": "Non esistono “puntatori di catena dinamica” in un record di attivazione",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "Permettono, a partire da un RdA, di trovare il RdA precedente sullo stack",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "In presenza di variabili modificabili",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Esistono un Ambiente che associa valori denotabili (fra cui le locazioni di memoria) a nomi ed una Memoria che associa locazioni di memoria a valori memorizzabili",
        "optionC": "Non esistono valori denotabili",
        "optionD": "La valutazione del comando di assegnamento restituisce sempre un valore",
        "optionE": "Il comando di assegnamento non ha effetti collaterali",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Se gli array sono memorizzati per colonne ed int a[100][100] è un array multidimensionale di interi (si assuma che la dimensione di un intero sia 4 byte)con a[0][0] che ha indirizzo 0x5000, qual è l'indirizzo di a[5][10]?",
        "optionA": "0x5510",
        "optionB": "0x53ED",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "0x500F",
        "optionE": "0x41FE",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Il concetto di variabile modificabile",
        "optionA": "È l'unico concetto utilizzabile quando si parla di variabili",
        "optionB": "È imposto dall'architettura di Von Neumann (variabili non modificabili richiederebbero macchine astratte caratterizzate da memoria a sola lettura)",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "È tipico del paradigma di programmazione imperativo",
        "optionE": "Permette di evitare il fenomeno dell'aliasing",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Nella sostituzione (λa.abc)[arrg/c]",
        "optionA": "E’ necessario applicare una Alfa-equivalenza per evitare una cattura di variabile",
        "optionB": "Viene catturata la variabile c",
        "optionC": "Si rischia di catturare la variabile “a” ed è necessario applicare Beta-equivalenza per risolvere in problema",
        "optionD": "Non c’è alcuna cattura di variabile",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta-riducendo (λn.λf.λx.f((nf)x))(λf.λx.f(f(f(fx)))) si ottiene",
        "optionA": "La riduzione non termina",
        "optionB": "fx",
        "optionC": "λf.λx.fffffx",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "λf.λx.f(f(f(fx))))",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Il fenomeno della cattura di variabili",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Non può essere evitato in alcun modo",
        "optionC": "Fa si che dopo una sostituzione una variabile libera diventi legata (per esempio da un’astrazione λx.)",
        "optionD": "Comporta la “sparizione” di variabili libere durante un’astrazione funzione",
        "optionE": "E’ dovuto all’assenza di un ambiente non locale",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Una Macchina Astratta ML (LO) è",
        "optionA": "E’ un modo per descrivere un interprete",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "E’ implementabile solo basandosi sull’architettura di Von Neumann",
        "optionD": "E’ un modo per descrivere un compilatore",
        "optionE": "E’ associata ad un proprio linguaggio macchina L, che è in grado di capire ed eseguire",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Se gli array sono memorizzati per righe e char a[100][100][100] è un un array multidimensionale di caratteri con a[0][0] che ha indirizzo 0x1000, qual è l’indirizzo di a[5][5][10]?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "0x51510",
        "optionC": "0xC54E",
        "optionD": "0xD54E",
        "optionE": "0x50510",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Il passaggio di parametri per nome",
        "optionA": "Permette di passare valori solo dal chiamante al chiamato (e non viceversa)",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "E’ implementabile passando una chiusura come parametro",
        "optionD": "Ha un valore solo teorico e non è implementabile in pratica",
        "optionE": "Permette la cattura di variabili libere in modo da effetti non deterministici",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "La tecnica del display",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Permette di implementare facilmente lo scope dinamico",
        "optionC": "Permette di ridurre il costo derivante dalla scansione della catena statica quando si implementa lo scope statico",
        "optionD": "Permette di visualizzare le zone di memoria allocata dinamicamente",
        "optionE": "Permette di implementare le regole di scope statico senza generare frammentazione della memoria",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Se gli array sono memorizzati per colonne e char a[100][100][100] è un un array multidimensionale di caratteri con a[0][0] che ha indirizzo 0x1000, qual è l’indirizzo di a[5][5][10]?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "0x18899",
        "optionC": "0x51510",
        "optionD": "0xD54E",
        "optionE": "0x19899",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Un compilatore da un linguaggio L ad un linguaggio LO è",
        "optionA": "Un programma che trasforma un programma PL (espresso nel linguaggio L) in un programma PLO (espresso nel linguaggio LO) tale che per ogni input I si ha PL(I) = PLO(I)",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Un programma scritto nel linguaggio LO che riceve come ingresso un programma PL (espresso nel linguaggio L) ed il suo input I generando lo stesso output che genera PL con input I",
        "optionD": "L’implementazione di una macchina astratta scritta nel linguaggio LO, che capisce programmi scritti nel linguaggio L",
        "optionE": "Una implementazione di macchine astratte indipendente dalla macchina fisica",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Il costrutto for dei linguaggi C, C++ e Java non è un costrutto di iterazione determinata perchè",
        "optionA": "L’esistenza di costrutti di iterazione derminata implicherebbe che C, C++ e Java non sono Turing-completi",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Dall’interno del ciclo è possibile modificare il valore del contatore",
        "optionD": "Non esistono costrutti di iterazione determinata",
        "optionE": "C, C++ e Java sono linguaggi imperativi",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Un oggetto denotabile (intendendo per “oggetto” una generica entità che può essere una variabile, una funzione, etc...) è",
        "optionA": "Un “oggetto” che può essere memorizzato in una variabile",
        "optionB": "Un “oggetto” per cui compare un binding nell’ambiente",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Un “oggetto” che ancora non compare nell’ambiente",
        "optionE": "Un “oggetto” che può essere generato come risultato da un’espressione complessa o da una funzione",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "L’ambiente non locale di un blocco di codice è",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "L’insieme dei valori che le variabili non locali possono assumere",
        "optionC": "L’insieme dei binding creati all’interno del blocco di codice",
        "optionD": "L’insieme dei binding visibili dentro al blocco, ma non direttamente definiti in esso",
        "optionE": "Il subset dell’ambiente non visibile dentro al blocco di codice",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Se gli array sono memorizzati per colonne e int a[25][25] è un un array multidimensionale di interi (si assuma che un intero sia memorizzato in 4 byte) con a[0][0] che ha indirizzo 0x1000, qual è l’indirizzo di a[5][10]?",
        "optionA": "0x11FE",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "0x100F",
        "optionD": "0x13FC",
        "optionE": "0x121C",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Beta-riducendo (λa.((aλb.λc.c)λd.λe.d))(λf.λg.f) si ottiene",
        "optionA": "λb.λc.c",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "La riduzione non termina",
        "optionD": "c",
        "optionE": "λb.λc.b",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "I puntatori di catena dinamica contenuti in un record di attivazione",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Non esistono \"puntatori di catena dinamica\" in un record di attivazione",
        "optionC": "Servono per identificare la zona di memoria in cui è memorizzata una variabile locale",
        "optionD": "Devono essere esplicitamente allocati e deallocati dal codice del programma che li usa",
        "optionE": "Servono per accedere alle variabili dinamiche",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta-riducendo (λx.xy)(λz.zx)(λz.zx) si ottiene",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "xyz",
        "optionC": "(λx.xy)yx",
        "optionD": "yx(λz.zx)",
        "optionE": "La riduzione non termina",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "L’allocazione dinamica della memoria",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "E’ sempre effettuata solo dal compilatore o dall’interprete",
        "optionC": "Può essere fatta solo dallo heap",
        "optionD": "Può essere fatta solo dallo stack",
        "optionE": "Può essere fatta sia dallo stack che dallo heap",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Un compilatore da un linguaggio L ad un linguaggio LO è",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Una implementazione di macchine astratte indipendente dalla macchina fisica",
        "optionC": "Un programma che trasforma un programma PLO (espresso nel linguaggio LO) in un programma PL (espresso nel linguaggio L) tale che per ogni input I si ha PL(I) = PLO(I)",
        "optionD": "L'implementazione di una macchina astratta scritta nel linguaggio LO, che capisce programmi scritti nel linguaggio L",
        "optionE": "Un programma scritto nel linguaggio LO che riceve come ingresso un programma PL (espresso nel linguaggio L) ed il suo input I generando lo stesso output che genera PL con input I",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "I dangling pointer",
        "optionA": "Sono identificabili tramite tecniche di reference counting (contatore dei riferimenti)",
        "optionB": "Sono un problema solo per il linguaggio Java",
        "optionC": "Sono identificabili tramite la tecnica detta \"mark and sweep\"",
        "optionD": "Non possono essere identificati con certezza, ma questo non è un problema perché comportano solo un piccolo spreco di memoria",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "La frammentazione esterna causa",
        "optionA": "Uno spreco di memoria",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "L'impossibilità di allocare grandi blocchi di memoria anche se la memoria libera totale è sufficiente",
        "optionD": "Un rallentamento rilevante nelle operazioni di allocazione della memoria",
        "optionE": "Il funzionamento non corretto di programmi che allocano memoria dinamicamente",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "La valutazione con corto circuito del predicato \"A && B\" (dove \"&&\" rappresenta un \"AND\" logico)",
        "optionA": "Stabilisce che se \"B\" è vero allora \"A\" non viene valutato",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Stabilisce che se \"A\" è falso allora \"B\" non viene valutato",
        "optionD": "Crea un non-determinismo nell'ordine della valutazione di \"A\" e \"B\"",
        "optionE": "Stabilisce che \"A\" e \"B\" devono essere valutati in parallelo",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Se l'ambiente di una funzione non contiene il nome della funzione stessa",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Non è possibile per la funzione invocarsi ricorsivamente",
        "optionC": "Non ci sono particolari conseguenze",
        "optionD": "La funzione non può usare scope dinamico",
        "optionE": "La funzione non può usare scope statico",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Se gli array sono memorizzati per colonne ed short int a[100][100] è un array multidimensionale di interi corti (si assuma che la dimensione di uno short int sia 2 byte) con a[0][0] che ha indirizzo 0x4100, qual è l'indirizzo di a[5][10]?",
        "optionA": "0x48DA",
        "optionB": "0x4510",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "0x47DA",
        "optionE": "0x41FE",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "La frammentazione interna causa",
        "optionA": "Il funzionamento non corretto di programmi che allocano memoria dinamicamente",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Un rallentamento rilevante nelle operazioni di allocazione della memoria",
        "optionD": "Uno spreco di memoria",
        "optionE": "L'impossibilità di allocare grandi blocchi di memoria anche se la memoria libera totale è suffciente",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "L'allocazione dinamica della memoria",
        "optionA": "Può essere fatta sia dallo stack che dallo heap",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "È sempre effettuata solo dal compilatore o dall'interprete",
        "optionD": "Può essere fatta solo dallo stack",
        "optionE": "Può essere fatta solo dallo heap",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta-riducendo (λn.λf.λx.f((nf)x))(λf.λx.ffffx) si ottiene",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "λf.λx.ffffffx",
        "optionC": "La riduzione non termina",
        "optionD": "λf.λx.fffffx",
        "optionE": "fx",
        "optionF": "L’espressione è irriducibile",
        "correct": "optionD"
    },
    {
        "question": "Beta f-riducendo ((λa.aaa)(λb.b))(λc.c) si ottiene",
        "optionA": "La riduzione non termina",
        "optionB": "aaa",
        "optionC": "λx.xa",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "λc.c",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "L'ambiente (o environment) è",
        "optionA": "L'insieme delle associazioni (nome, entità denotabile) esistenti in uno specifico punto del programma ed in uno specifico momento durante l'esecuzione di un programma",
        "optionB": "L'insieme dei valori che una variabile assume durante l'esecuzione di un programma",
        "optionC": "Un insieme di associazioni (nome, valore) definite staticamente durante lo sviluppo di un programma",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "Una lista di coppie (nome, tipo) che permette di accedere alle variabili di un programma",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta f-riducendo (λa.aaa)((λb.b)(λc.c)) si ottiene",
        "optionA": "λa.a",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "aaa",
        "optionD": "La riduzione non termina",
        "optionE": "λx.xa",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Si può dire che una macchina astratta che capisce il linguaggio Java non sia implementata in modo puramente compilativo perché",
        "optionA": "Non esistendo un vero e proprio runtime per Java, non si può parlare di compilazione pura",
        "optionB": "La macchina virtuale di Java (JVM) deve comunque essere compilata",
        "optionC": "Una macchina astratta che capisca un linguaggio di alto livello come Java non è mai implementabile con un compilatore",
        "optionD": "Non esistono compilatori Java",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "La ricorsione in coda",
        "optionA": "Permette di risolvere il problema della ricorsione infinita",
        "optionB": "Richiede di non scrivere mai la chiamata ricorsiva come ultimo statement di una subroutine",
        "optionC": "Richiede di non ritornare mai direttamente il valore ritornato da una chiamata ricorsiva",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "Permette di evitare un'eccessiva crescita della dimensione dello stack",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "La memoria gestita staticamente",
        "optionA": "E’ allocata esplicitamente dal programma a tempo di esecuzione, ma una volta allocata è staticamente legata al programma e non può essere liberata fino alla sua terminazione",
        "optionB": "E’ allocata prima dell’esecuzione del programma. Le entità allocate staticamente possono essere deallocate durante l’esecuzione del programma, per liberare memoria",
        "optionC": "E’ allocata dal compilatore prima dell’esecuzione del programma. Le entità allocate staticamente in memoria risiedono in una zona fissa di memoria durante tutta l’esecuzione del programma",
        "optionD": "E’ una memoria a sola lettura",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Se gli array sono memorizzati per colonne e char a[100][100] è un array multidimensionale di caratteri con a[0][0] che ha indirizzo 0x1100, qual è l'indirizzo di a[5][10]?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "0x24ED",
        "optionC": "0x21FE",
        "optionD": "0x22FE",
        "optionE": "0x14ED",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Se gli array sono memorizzati per colonne e char a[100][100] è un array multidimensionale di caratteri con a[0][0] che ha indirizzo 5243, qual è l'indirizzo di a[5][10]? (i numeri sono in decimale)",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "5753",
        "optionC": "6248",
        "optionD": "4730",
        "optionE": "4955",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Un interprete di un linguaggio L scritto in un linguaggio LO è",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "L'implementazione di una macchina astratta scritta nel linguaggio LO, che capisce programmi scritti nel linguaggio L",
        "optionC": "Una implementazione di macchine astratte indipendente dalla macchina fisica",
        "optionD": "Un programma scritto nel linguaggio LO che riceve come ingresso un programma PL (espresso nel linguaggio L) ed il suo input I generando lo stesso output che genera PL con input I",
        "optionE": "Un programma che trasforma un programma PL (espresso nel linguaggio L) in un programma PLO (espresso nel linguaggio LO) tale che per ogni input I si ha PL(I) = PLO(I)",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "In caso di scope statico",
        "optionA": "Non è possibile annidare più blocchi di istruzioni",
        "optionB": "I legami fra nomi ed oggetto possono essere determinati solo a tempo di esecuzione",
        "optionC": "Il valore assegnato ad una variabile non può essere modificato",
        "optionD": "I legami fra nomi ed oggetto possono essere determinati semplicemente leggendo il testo di un programma",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Un garbage collector",
        "optionA": "Può essere implementato tramite la tecnica detta “mark and sweep”, che riesce sempre ad identificare tutta la memoria allocata dinamicamente ma non più utilizzata",
        "optionB": "Richiede un’implementazione complessa, usando la tecnica dei tombstone (pietre tombali)",
        "optionC": "E’ implementabile solo in linguaggi di programmazione funzionali",
        "optionD": "E’ implementabile tramite la tecnica di lucchetti e chiavi, che però può causare dei memory leak",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Se gli array sono memorizzati per colonne ed short int a[100][100] è un array multidimensionale di interi corti (si assuma che la dimensione di uno short int sia 2 byte) con a[0][0] che ha indirizzo 0x4100, qual è l’indirizzo di a[5][10]?",
        "optionA": "0x41FE",
        "optionB": "0x500F",
        "optionC": "0x47DA",
        "optionD": "0x4510",
        "optionE": "0x43ED",
        "optionF": "Nessuna delle altre risposte",
        "correct": "optionF"
    },
    {
        "question": "Beta f-riducendo (λd.((λa.abc)(bc)))(λy.xyz) si ottiene",
        "optionA": "La riduzione non termina",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "λb.bba",
        "optionD": "λa.abc",
        "optionE": "bcbc",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Un interprete di un linguaggio L scritto in un linguaggio LO è",
        "optionA": "Un programma che trasforma un programma PL (espresso nel linguaggio L) in un programma PLO (espresso nel linguaggio LO) tale che per ogni input I si ha PL(I) = PLO(I)",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Una implementazione di macchine astratte indipendente dalla macchina fisica",
        "optionD": "Un programma scritto nel linguaggio L che dato un input I produce lo stesso output generato dallo stesso programma scritto nel linguaggio LO",
        "optionE": "L’implementazione di una macchina astratta scritta nel linguaggio LO, che capisce programmi scritti nel linguaggio L",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L’ambiente (o environment) è",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Un insieme di associazioni (nome, valore) definite staticamente durante lo sviluppo di un programma",
        "optionC": "L’insieme delle associazioni (variabile, valore) esistenti in uno specifico punto del programma ed in uno specifico momento durante l’esecuzione di un programma",
        "optionD": "L’insieme dei valori che una variabile assume durante l’esecuzione di un programma",
        "optionE": "Una lista di coppie (nome, tipo) che permette di accedere alle variabili di un programma",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Se gli array sono memorizzati per righe ed int a[100][100] è un un array multidimensionale di interi (si assuma che la dimensione di un intero sia 4 byte) con a[0][0] che ha indirizzo 0x1000, qual è l’indirizzo di a[5][10]?",
        "optionA": "0x100F",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "0x13ED",
        "optionD": "0x11FE",
        "optionE": "0x1510",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Beta f-riducendo (λn.λf.λx.f((nf)x))(λf.λx.f(f(f(fx)))) si ottiene ",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "L’espressione è irriducibile",
        "optionC": "La riduzione non termina",
        "optionD": "λf.λx.fffffx",
        "optionE": "fx",
        "optionF": "λf.λx.f(f(f(f(fx))))",
        "correct": "optionF"
    },
    {
        "question": "Un garbage collector",
        "optionA": "Richiede un’implementazione complessa, usando la tecnica dei tombstone (pietre tombali)",
        "optionB": "E’ implementabile solo in linguaggi di programmazione funzionali",
        "optionC": "Può essere implementato tramite la tecnica del reference counting (contatore dei riferimenti), che riesce sempre ad identificare tutta la memoria allocata dinamicamente ma non più utilizzata",
        "optionD": "E’ implementabile tramite la tecnica di lucchetti e chiavi, che però può causare dei memory leak",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Se gli array sono memorizzati per righe e char a[100][100] è un array multidimensionale di caratteri con a[0][0] che ha indirizzo 0x2000, qual è l’indirizzo di a[5][10]?",
        "optionA": "0x200F",
        "optionB": "0x21FE",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "0x23ED",
        "optionE": "0x2510",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Beta-riducendo (λn.λm.λf.λx.(nf)((mf)x))(λf.λx.fx)(λf.λx.x) si ottiene",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "x",
        "optionC": "λf.λx.ffffffx",
        "optionD": "λf.λx.fx",
        "optionE": "fx",
        "optionF": "λf.λx.ffffx",
        "correct": "optionD"
    },
    {
        "question": "Beta-riducendo (λa.((aλb.λc.c)λd.λe.d))(λf.λg.g) si ottiene",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "λb.λc.b",
        "optionC": "b",
        "optionD": "λb.λc.c",
        "optionE": "La riduzione non termina",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L’ambiente (o environment) è",
        "optionA": "Un insieme di associazioni (nome, valore) definite staticamente durante lo sviluppo di un programma",
        "optionB": "Una lista di coppie (nome, tipo) che permette di accedere alle variabili di un programma",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "L’insieme dei valori che una variabile assume durante l’esecuzione di un programma",
        "optionE": "L’insieme delle associazioni (nome, oggetto denotabile) esistenti in uno specifico punto del programma ed in uno specifico momento durante l’esecuzione di un programma",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "In caso di scope dinamico",
        "optionA": "Il valore assegnato ad una variabile non può essere modificato",
        "optionB": "Non è possibile annidare più blocchi di istruzioni",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "I legami fra nomi ed oggetto possono essere determinati solo a tempo di esecuzione",
        "optionE": "I legami fra nomi ed oggetto possono essere determinati semplicemente leggendo il testo di un programma",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Beta-riducendo (λa.aab)((λa.aab)(λa.(λb.ba)c)) si ottiene",
        "optionA": "La riduzione non termina",
        "optionB": "aab",
        "optionC": "λa.aab",
        "optionD": "ccb(ccb)c",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Un entità denotabile è",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Un entità che può essere generata come risultato da un espressione complessa o da una Funzione",
        "optionC": "Una generica entità a cui può essere dato un nome",
        "optionD": "Un'entità che ancora non compare nell'ambiente",
        "optionE": "Un'entità che può essere memorizzata",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "I puntatori di catena statica contenuti in un record di attivazione",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Servono per accedere alle variabili statiche",
        "optionC": "Devono essere esplicitamente allocati e deallocati dal codice del programma che li usa",
        "optionD": "Servono per identificare la zona di memoria in cui è memorizzata una variabile in caso di scope statico",
        "optionE": "Non esistono puntatori di catena statica in un record d'attivazione",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "La memoria gestita dinamicamente",
        "optionA": "È usata solo in linguaggi interpretati",
        "optionB": "Non è mai strettamente necessaria, ma permette di ottenere migliori prestazioni",
        "optionC": "È necessaria per implementare la ricorsione",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "È necessaria per implementare l'iterazione",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Se gli array sono memorizzati per colonne ed int a[100][100] è un array multidimensionale di interi (si assuma che la dimensione di un intero sia 4 byte) con a[0][0] che ha indirizzo 0x5000, qual è l'indirizzo di a[5][10]?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "0x53ED",
        "optionC": "0x500F",
        "optionD": "0x41FE",
        "optionE": "0x5510",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta riducendo (λa.aab)((λa.aab)(λa.(λb.ba)c)) si ottiene",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "ccb(ccb)c",
        "optionC": "λa.aab",
        "optionD": "La riduzione non termina",
        "optionE": "aab",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta-riducendo ((λa.aaa)(λb.b))(λc.c) si ottiene",
        "optionA": "λc.c",
        "optionB": "La riduzione non termina",
        "optionC": "aaa",
        "optionD": "λx.xa",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta-riducendo (λd.((λa.abc)(bc)))(λy.xyz) si ottiene",
        "optionA": "La riduzione non termina",
        "optionB": "bcbc",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "λa.abc",
        "optionE": "λb.bba",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Un entità denotabile può avere un tempo di vita più lungo di quello delle associazioni (fra l'entità ed identificatori) che lo riferiscono",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Se l'entità è allocata dinamicamente dallo heap in una subroutine",
        "optionC": "Mai",
        "optionD": "Se l'entità è allocata dinamicamente dallo stack in una subroutine",
        "optionE": "Se si usa scope dinamico",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "La memoria gestita dinamicamente",
        "optionA": "Non è mai strettamente necessaria, ma permette di ottenere migliori prestazioni",
        "optionB": "È necessaria per implementare l'iterazione",
        "optionC": "È usata solo in linguaggi interpretati",
        "optionD": "È necessaria solo per implementare macchine astratte per linguaggi compilati",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "I record d'attivazione",
        "optionA": "Devono essere esplicitamente allocati e deallocati dal codice del programma che li usa",
        "optionB": "Possono essere allocati sia sullo stack sia sullo heap (in caso, per esempio, di funzioni di ordine superiore)",
        "optionC": "Sono necessari solo in presenza di funzioni di ordine superiore",
        "optionD": "Sono allocati solo sullo heap",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "<div class='code'>int c = 2; <br> int pippo(int a) { <br>&nbsp;&nbsp;&nbsp;c = c + 2; <br>&nbsp;&nbsp;&nbsp;return a * 2; <br>} <br>int pluto(void) {<br>&nbsp;&nbsp;&nbsp;return pippo(c + 1); <br>}</div>Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per nome?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "10",
        "optionC": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionD": "4",
        "optionE": "6",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "<div class='code'>int c = 2; <br> int pippo(int a) { <br>&nbsp;&nbsp;&nbsp;c = c + 2; <br>&nbsp;&nbsp;&nbsp;return a * 2; <br>} <br>int pluto(void) {<br>&nbsp;&nbsp;&nbsp;return pippo(c + 1); <br>}</div>Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per valore?",
        "optionA": "10",
        "optionB": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "6",
        "optionE": "Non è possibile passare c + 1 per valore",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "<div class='code'>int r(int x) {<br>&nbsp;&nbsp;&nbsp; return r(x - 1);<br>}<br>int f(int a, int b, int c) {<br>&nbsp;&nbsp;&nbsp;if (c == 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a;<br>&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return b;<br>}</div>Si consideri lo pseudo-codice. Qual è il valore di ritorno di f(1,r(1),1) se i parametri sono passati per nome?",
        "optionA": "Non è possibile dirlo senza conoscere il tipo di scope (statico o dinamico) utilizzato",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "1",
        "optionD": "Si ha ricorsione infinita",
        "optionE": "0",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "<div class='code'>int a, b, c;<br>void pippo(void) {<br>&nbsp;&nbsp;&nbsp;int a;<br>&nbsp;&nbsp;&nbsp;a = 6;<br>&nbsp;&nbsp;&nbsp;b = 5;<br>}<br>  void pluto(void) {<br>  &nbsp;&nbsp;&nbsp;int c;<br>  &nbsp;&nbsp;&nbsp;int b;<br>  &nbsp;&nbsp;&nbsp;pippo();<br>  &nbsp;&nbsp;&nbsp;c = 3;<br>  &nbsp;&nbsp;&nbsp;a = 4;<br>  }<br>  void topolino(void) {<br>  &nbsp;&nbsp;&nbsp;int a;<br>  &nbsp;&nbsp;&nbsp;a = 1;<br>  &nbsp;&nbsp;&nbsp;b = 10;<br>&nbsp;&nbsp;&nbsp;pluto();<br>&nbsp;&nbsp;&nbsp;c = a + b;<br>}</div>Dato il frammento di programma (espresso in pseudo-codice), quanto vale la variabile globale c dopo aver eseguito topolino(), assumendo scope dinamico?",
        "optionA": "14",
        "optionB": "3",
        "optionC": "Non è possibile dirlo",
        "optionD": "6",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "<div class='code'>  int x, y, z;<br>  void f3(void) {<br>      &nbsp;&nbsp;&nbsp;x = 0;<br>      &nbsp;&nbsp;&nbsp;y = 5;<br>  }<br>  void f2(void) {<br>      &nbsp;&nbsp;&nbsp;int y;<br>      &nbsp;&nbsp;&nbsp;f3();<br>      &nbsp;&nbsp;&nbsp;y = 0;<br>      &nbsp;&nbsp;&nbsp;z = 10;<br>  }<br>  int f1(void) {<br>      &nbsp;&nbsp;&nbsp;int x;<br>      &nbsp;&nbsp;&nbsp;x = -5;<br>      &nbsp;&nbsp;&nbsp;y = 10;<br>      &nbsp;&nbsp;&nbsp;z = x + y;<br>      &nbsp;&nbsp;&nbsp;f2();<br>      &nbsp;&nbsp;&nbsp;return z - y - x;<br>  }<br></div>  Dato il frammento di programma (espresso in pseudo-codice), qual è il valore di ritorno di f1(), assumendo scope statico?",
        "optionA": "5",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Non è possibile dirlo",
        "optionD": "0",
        "optionE": "-5",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "<div class='code'>  int b = 666;<br>  int pippo(int x) {<br>      &nbsp;&nbsp;&nbsp;x = 666;<br>      &nbsp;&nbsp;&nbsp;b = 1;<br>      &nbsp;&nbsp;&nbsp;return x / 2;<br>  }<br>  int pluto(void) {<br>      &nbsp;&nbsp;&nbsp;int a, c;<br>      &nbsp;&nbsp;&nbsp;a = b / 333;<br>      &nbsp;&nbsp;&nbsp;c = pippo(a);<br>      &nbsp;&nbsp;&nbsp;return a + c;<br>  }</div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per valore?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "1",
        "optionC": "3",
        "optionD": "0",
        "optionE": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "<div class='code'>  int somma(int a, int b) {<br>      &nbsp;&nbsp;&nbsp;if (a == 0)<br>      &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp; return b;<br>     &nbsp;&nbsp;&nbsp; return somma(a - 1, b + 1);<br>  }<br></div>  Funzione implementata dallo pseudo-codice",
        "optionA": "Non usa ricorsione in coda",
        "optionB": "Non può essere implementata per via iterativa",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Causa sempre ricorsione infinita",
        "optionE": "Usa ricorsione in coda",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "<div class='code'>  int f4(int x) {<br>      &nbsp;&nbsp;&nbsp;return 1 / x;<br>  }<br>  int f3(int a, int b) {<br>      &nbsp;&nbsp;&nbsp;if (a > 1)<br>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return a;<br>     &nbsp;&nbsp;&nbsp; else<br>         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;<br>  }<br></div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di f3(10,f4(0)) se i parametri sono passati per valore?",
        "optionA": "10",
        "optionB": "Non è possibile dirlo senza conoscere il tipo di scope (statico o dinamico) utilizzato",
        "optionC": "Non è possibile passare f4(0) per valore",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "1",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "<div class='code'>  int i = 0;<br>  int x[10];<br>  int f2(int z) {<br>      &nbsp;&nbsp;&nbsp;i = i / 2;<br>      &nbsp;&nbsp;&nbsp;return z - i;<br>  }<br>  int f1(void) {<br>      &nbsp;&nbsp;&nbsp;int y;<br>      &nbsp;&nbsp;&nbsp;i = 4;<br>      &nbsp;&nbsp;&nbsp;x[0] = 1;<br>      &nbsp;&nbsp;&nbsp;x[1] = 0;<br>      &nbsp;&nbsp;&nbsp;x[2] = 2;<br>      &nbsp;&nbsp;&nbsp;x[3] = 4;<br>      &nbsp;&nbsp;&nbsp;x[4] = 6;<br>      &nbsp;&nbsp;&nbsp;y = f2(x[i]);<br>      &nbsp;&nbsp;&nbsp;return y + i;<br>  }<br></div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di f1() se i parametri sono passati per valore?",
        "optionA": "0",
        "optionB": "2",
        "optionC": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionD": "4",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "<div class='code'>  int x, y, z;<br>  void f3(void) {<br>     &nbsp;&nbsp;&nbsp; x = 0;<br>     &nbsp;&nbsp;&nbsp; y = 5;<br>  }<br>  void f2(void) {<br>     &nbsp;&nbsp;&nbsp; int y;<br>      &nbsp;&nbsp;&nbsp;f3();<br>     &nbsp;&nbsp;&nbsp; y = 0;<br>     &nbsp;&nbsp;&nbsp; z = 10;<br>  }<br>  int f1(void) {<br>     &nbsp;&nbsp;&nbsp; int x;<br>    &nbsp;&nbsp;&nbsp;  x = -5;<br>    &nbsp;&nbsp;&nbsp;  y = 10;<br>    &nbsp;&nbsp;&nbsp;  z = x + y;<br>    &nbsp;&nbsp;&nbsp;  f2();<br>    &nbsp;&nbsp;&nbsp;  return z - y - x;<br>  }</div>  Dato il frammento di programma (espresso in pseudo-codice), qual è il valore di ritorno di f1(), assumendo scope dinamico?",
        "optionA": "Non è possibile dirlo",
        "optionB": "5",
        "optionC": "0",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "-5",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "<div class='code'>  int b = 666;<br>  int pippo(int x) {<br>    &nbsp;&nbsp;&nbsp;  x = 666; b = 1;<br>     &nbsp;&nbsp;&nbsp; return x / 2;<br>  }<br>  int pluto(void) {<br>     &nbsp;&nbsp;&nbsp; int a, c;<br>     &nbsp;&nbsp;&nbsp; a = b / 333;<br>     &nbsp;&nbsp;&nbsp; c = pippo(a);<br>     &nbsp;&nbsp;&nbsp; return a + c;<br>  }</div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per valore?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "666",
        "optionC": "999",
        "optionD": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionE": "333",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "<div class='code'>  int somma(int a, int b) {<br>    &nbsp;&nbsp;&nbsp;  if (a == 0) return b;<br>     &nbsp;&nbsp;&nbsp; return somma(a - 1, b) + 1;<br>  }</div>  Funzione implementata dallo pseudo-codice",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Non può essere implementata per via iterativa",
        "optionC": "Causa sempre ricorsione infinita",
        "optionD": "Usa ricorsione in coda",
        "optionE": "Non usa ricorsione in coda",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "<div class='code'>  int b = 666;<br>  int pippo(int x) {<br>   &nbsp;&nbsp;&nbsp;   x = 666; b = 1;<br>    &nbsp;&nbsp;&nbsp;  return x / 2;<br>  }<br>  int pluto(void) {<br>    &nbsp;&nbsp;&nbsp;  int a, c;<br>   &nbsp;&nbsp;&nbsp;   a = b / 333;<br>     &nbsp;&nbsp;&nbsp; c = pippo(a);<br>    &nbsp;&nbsp;&nbsp;  return a + c;<br>  }<br></div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per nome?",
        "optionA": "Non è possibile passare a per nome",
        "optionB": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "335",
        "optionE": "999",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "<div class='code'>  int mistero(int a, int b) {<br>    &nbsp;&nbsp;&nbsp;  if (b == 0) return a;<br>   &nbsp;&nbsp;&nbsp;   return mistero(a / 2, b - 1);<br>  }<br></div>  La funzione implementata dallo pseudo-codice",
        "optionA": "Può causare una crescita incontrollata dello stack",
        "optionB": "Causa sempre ricorsione infinita",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Non può essere implementata per via iterativa",
        "optionE": "Non usa ricorsione in coda",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "<div class='code'>  int x, y;<br>  void pippo(void) {<br>   &nbsp;&nbsp;&nbsp;   x = 8;<br>    &nbsp;&nbsp;&nbsp;  y = 4;<br>  }<br>  void pluto(void) {<br>    &nbsp;&nbsp;&nbsp;  int y;<br>    &nbsp;&nbsp;&nbsp;  pippo();<br>    &nbsp;&nbsp;&nbsp;  y = 3;<br>  }<br>  int topolino(void) {<br>    &nbsp;&nbsp;&nbsp;  int x, z;<br>    &nbsp;&nbsp;&nbsp;  x = 5;<br>   &nbsp;&nbsp;&nbsp;   y = 15;<br>    &nbsp;&nbsp;&nbsp;  z = x + y;<br>    &nbsp;&nbsp;&nbsp;  pluto();<br>    &nbsp;&nbsp;&nbsp;  return z - y - x;<br>  }</div>  Dato il frammento di programma (espresso in pseudo-codice), qual è il valore di ritorno di topolino(), assumendo scope statico?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Non è possibile dirlo",
        "optionC": "0",
        "optionD": "-3",
        "optionE": "11",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "<div class='code'>  int x, y, z;<br>  void f3(void) {<br>    &nbsp;&nbsp;&nbsp;  x = 0;<br>    &nbsp;&nbsp;&nbsp;  y = 5;<br>  }<br>  void f2(void) {<br>    &nbsp;&nbsp;&nbsp;  int y;<br>    &nbsp;&nbsp;&nbsp;  f3();<br>    &nbsp;&nbsp;&nbsp;  y = 0;<br>     &nbsp;&nbsp;&nbsp; z = 10;<br>  }<br>  int f1(void) {<br>    &nbsp;&nbsp;&nbsp;  int x;<br>   &nbsp;&nbsp;&nbsp;   x = -5;<br>    &nbsp;&nbsp;&nbsp;  y = 10;<br>    &nbsp;&nbsp;&nbsp;  z = x + y;<br>   &nbsp;&nbsp;&nbsp;   f2();<br>   &nbsp;&nbsp;&nbsp;   return z - y - x;<br>  }<br></div>  Dato il frammento di programma (espresso in pseudo-codice), qual è il valore di ritorno di f1(), assumendo scope dinamico?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "-1",
        "optionC": "-5",
        "optionD": "5",
        "optionE": "Non è possibile dirlo",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "<div class='code'>  int c = 2;<br>  int pippo(int a) {<br>   &nbsp;&nbsp;&nbsp;   c = c + 2;<br>   &nbsp;&nbsp;&nbsp;   return a * 2;<br>  }<br>  int pluto(void) {<br>   &nbsp;&nbsp;&nbsp;   return(pippo(c + 1));<br>  }</div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per valore?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionC": "Non è possibile passare c + 1 per valore",
        "optionD": "6",
        "optionE": "10",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "<div class='code'>  int r(int x) {<br>     &nbsp;&nbsp;&nbsp; return r(x - 1);<br>  }<br>  int f(int a, int b, int c) {<br>    &nbsp;&nbsp;&nbsp;  if (c == 1) return a; else return b;<br>  }<br></div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di f(1,r(1),1) se i parametri sono passati per valore?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Si ha ricorsione infinita",
        "optionC": "1",
        "optionD": "Non è possibile dirlo senza conoscere il tipo di scope (statico o dinamico) utilizzato",
        "optionE": "0",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "<div class='code'>  int x, y, z;<br>  void minni(void) {<br>   &nbsp;&nbsp;&nbsp;   x = 4;<br>   &nbsp;&nbsp;&nbsp;   y = 8;<br>  }<br>  void paperino(void) {<br>   &nbsp;&nbsp;&nbsp;   int y;<br>   &nbsp;&nbsp;&nbsp;   minni();<br>    &nbsp;&nbsp;&nbsp;  y = 1;<br>    &nbsp;&nbsp;&nbsp;  z = 666;<br>  }<br>  int topolino(void) {<br>   &nbsp;&nbsp;&nbsp;   int x;<br>    &nbsp;&nbsp;&nbsp;  x = 5;<br>    &nbsp;&nbsp;&nbsp;  y = 15;<br>    &nbsp;&nbsp;&nbsp;  z = x + y;<br>    &nbsp;&nbsp;&nbsp;  paperino();<br>    &nbsp;&nbsp;&nbsp;  return z - y - x;<br>  }<br></div>  Dato il frammento di programma (espresso in pseudo-codice), qual è il valore di ritorno di topolino(), assumendo scope statico?",
        "optionA": "-3",
        "optionB": "0",
        "optionC": "14",
        "optionD": "Non è possibile dirlo",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "<div class='code'>  int c = 2;<br>  int pippo(int a) {<br>    &nbsp;&nbsp;&nbsp;  c = c + 2;<br>     &nbsp;&nbsp;&nbsp; return a * 2;<br>  }<br>  int pluto(void) {<br>    &nbsp;&nbsp;&nbsp;  return(pippo(c + 1));<br>  }<br></div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per riferimento?",
        "optionA": "Dipende dal tipo di scope (statico o dinamico) utilizzato",
        "optionB": "10",
        "optionC": "Non è possibile passare c + 1 per riferimento",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "6",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "<div class='code'>  int a, b, c;<br>  void pippo(void) {<br>    &nbsp;&nbsp;&nbsp;  int a;<br>    &nbsp;&nbsp;&nbsp;  a = 6;<br>    &nbsp;&nbsp;&nbsp;  b = 5;<br>  }<br>  void pluto(void) {<br>    &nbsp;&nbsp;&nbsp;  int c;<br>    &nbsp;&nbsp;&nbsp;  int b;<br>    &nbsp;&nbsp;&nbsp;  pippo();<br>     &nbsp;&nbsp;&nbsp; c = 3;<br>     &nbsp;&nbsp;&nbsp; a = 4;<br>  }<br>  void topolino(void) {<br>     &nbsp;&nbsp;&nbsp; int a;<br>    &nbsp;&nbsp;&nbsp;  a = 1;<br>    &nbsp;&nbsp;&nbsp;  b = 10;<br>     &nbsp;&nbsp;&nbsp; pluto();<br>     &nbsp;&nbsp;&nbsp; c = a + b;<br>  }<br></div>  Dato il frammento di programma (espresso in pseudo-codice), quanto vale la variabile globale c dopo aver eseguito topolino(), assumendo scope statico?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "6",
        "optionC": "Non è possibile dirlo",
        "optionD": "14",
        "optionE": "3",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun f x y = x y;</div>",
        "optionA": "fun: 'a->'b",
        "optionB": "fun: 'a->'b->string->string",
        "optionC": "fun: ('a->'b)->'a->'b",
        "optionD": "fun: int->int",
        "optionE": "fun: string->string->string->string",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>List.map print string;</div>",
        "optionA": "fun : string list -> string list",
        "optionB": "fun : string list -> unit list",
        "optionC": "fun : string list -> string",
        "optionD": "fun : string -> string list",
        "optionE": "fun: string -> unit",
        "optionF": "fun: 'a list -> 'b list",
        "correct": "optionB"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>let f1 l = List.map (fun x y -> x,y) l;</div>",
        "optionA": "f1:'a list->('b -> 'a -> 'b) list",
        "optionB": "f1:'a list-> 'b -> ('a * 'b)",
        "optionC": "fun x y -> x,y :'a -> 'b -> 'a * 'b",
        "optionD": "fun x y -> x,y :'a -> 'b -> 'a -> 'b",
        "optionE": "f1:'a list->('b -> 'a * 'b) list",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>(fn x => x) 12;</div>",
        "optionA": "12: int",
        "optionB": "'a: 12",
        "optionC": "string: \"12\"",
        "optionD": "fn: 'a -> 'a",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun f1 x = [x,x];</div>",
        "optionA": "f1 = fn: 'a list -> 'a list",
        "optionB": "f1 = fn: 'a list -> 'b list",
        "optionC": "f1 = fn: 'a -> 'b",
        "optionD": "f1 = fn: 'a -> 'a list",
        "optionE": "f1 = fn: 'a -> 'a",
        "optionF": "f1 = fn: string -> string",
        "correct": "optionD"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun f2 x y = (x @ (y x));</div>",
        "optionA": "fun: 'a -> 'a -> 'a -> 'a",
        "optionB": "fun: 'a list -> ('a list -> 'a list) -> 'a list",
        "optionC": "fun: 'a list -> 'a list -> 'a list",
        "optionD": "fun: 'a list -> 'a list -> 'b list",
        "optionE": "fun: 'a -> ('a list -> 'a list) -> 'a list",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun f3 x = List.map x;</div>",
        "optionA": "fun : ('a list -> 'b list) -> 'a list -> 'b list",
        "optionB": "fun : ('a -> 'b) -> 'a -> 'b",
        "optionC": "fun : ('a -> 'a) -> 'a list -> 'a list",
        "optionD": "fun : 'a list -> 'b list",
        "optionE": "fun : ('a -> 'b) -> 'a list -> 'b list",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fn x => fn y => x+y;</div>",
        "optionA": "fn: int -> int",
        "optionB": "fn: 'a -> 'a -> 'a",
        "optionC": "fn: int -> int -> int",
        "optionD": "fn: 'a -> 'a",
        "optionE": "fn: int -> int -> 'a",
        "optionF": "Nessuna delle altre risposte",
        "correct": "optionC"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun funzione x y z = x ^ y ^ z</div>",
        "optionA": "fn: string -> string",
        "optionB": "fn: 'a -> 'a",
        "optionC": "fn: 'a -> 'a -> 'a -> 'a",
        "optionD": "fn: string -> string -> string -> int",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "fn: string -> string -> string -> string",
        "correct": "optionF"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun c a1 a2 = a1::a2;</div>",
        "optionA": "fn: 'a list -> 'a list -> 'a list",
        "optionB": "fn: 'a -> 'a list -> 'a list",
        "optionC": "fn: 'a -> 'a -> 'a",
        "optionD": "fn: 'a -> 'a list",
        "optionE": "fn: 'a -> 'a -> 'a list",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fn l1 => fn l2 => l1@l2;</div>",
        "optionA": "fn: 'a list -> 'a list -> 'a list",
        "optionB": "fn: 'a -> 'a list -> 'a list",
        "optionC": "fn: 'a -> 'a -> 'a",
        "optionD": "fn: 'a -> 'a list",
        "optionE": "fn: 'a -> 'a -> 'a list",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fn a => fn b => fn c => (a * b) / c;</div>",
        "optionA": "fn: int -> int -> int -> int",
        "optionB": "fn: 'a -> 'a -> 'a -> 'a",
        "optionC": "fn: int -> int -> int -> real",
        "optionD": "fn: real -> real -> real -> real",
        "optionE": "fn: int -> int -> real -> real",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun f [] = (7.0; print(\"ab\")) | f (x::xs) = (2.3; print(\"cd\"));</div>",
        "optionA": "val f = fn: 'a list -> unit ",
        "optionB": "'a list -> int",
        "optionC": "'a tuple",
        "optionD": "val f = fn: 'a list -> real",
        "optionE": "real list -> string",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Qual è l'output del seguente codice: <div class='code'>List.partition(fn x => x > 0) (List.take ([~1,1,~2,~2,~3,3],4));</div>",
        "optionA": "val it = ([1,3], [~1, ~2, ~2, ~3]): int list * int list",
        "optionB": "val it = [1,3]: int list",
        "optionC": "val it = [1]: int list",
        "optionD": "val it = ([1], [~1, ~2, ~2]): int list * int list",
        "optionE": "val it = ([], [~2]): int list * int list",
        "optionF": "val it = []: int list",
        "correct": "optionD"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fn a => fn b => a = b;</div>",
        "optionA": "fn: ''a -> ''a -> bool",
        "optionB": "fn: int -> int -> bool",
        "optionC": "fn: string -> string -> bool",
        "optionD": "fn: bool -> bool -> bool",
        "optionE": "fn: 'a -> 'a -> bool",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Quale delle seguenti affermazioni riguardanti il garbage collector è vera",
        "optionA": "Per Garbage Collection si intende una modalità automatica di gestione della memoria",
        "optionB": "L’utente alloca liberamente memoria",
        "optionC": "Non è permesso deallocare memoria",
        "optionD": "Il sistema periodicamente recupera la memoria allocata e non più utilizzabile",
        "optionE": "Un sistema operativo, o un compilatore, e un modulo di run-time liberano porzioni di memoria non più utilizzate dalle applicazioni.",
        "optionF": "Tutte sono corrette",
        "correct": "optionF"
    },
    {
        "question": "Quale delle seguenti affermazioni riguardanti il Garbage Collector è falsa",
        "optionA": "Il garbage collector annoterà le aree di memoria non più referenziate e le libererà automaticamente",
        "optionB": "L’utente alloca liberamente memoria",
        "optionC": "È permesso deallocare memoria",
        "optionD": "Un sistema operativo, o un compilatore, e un modulo di run-time liberano porzioni di memoria non più utilizzate dalle applicazioni.",
        "optionE": "Il sistema periodicamente recupera la memoria allocata e non più utilizzabile",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Se gli array sono memorizzati per righe e char a[100][100] è un array multidimensionale di caratteri con a[0][0] che ha indirizzo 0x1100, qual è l’indirizzo di a[5][10]?",
        "optionA": "0x22FE",
        "optionB": "0x12FE",
        "optionC": "0x1510",
        "optionD": "0x210F",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "<div class='code'>  int b = 666;<br>  int pippo(int x) {<br>    &nbsp;&nbsp;&nbsp;  x = 666; b = 1;<br>     &nbsp;&nbsp;&nbsp; return x / 2;<br>  }<br>  int pluto(void) {<br>     &nbsp;&nbsp;&nbsp; int a, c;<br>     &nbsp;&nbsp;&nbsp; a = b / 333;<br>     &nbsp;&nbsp;&nbsp; c = pippo(a);<br>     &nbsp;&nbsp;&nbsp; return a + c;<br>  }</div>  Si consideri lo pseudo-codice. Qual è il valore di ritorno di pluto() se i parametri sono passati per riferimento?",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "333",
        "optionC": "999",
        "optionD": "Non è possibile passare a per riferimento (perché a = b / 333)",
        "optionE": "666",
        "optionF": "2",
        "correct": "optionC"
    },
    {
        "question": "Considerando la macchina astratta che permette di eseguire un linguaggio L, il numero di record di attivazione contemporaneamente presenti nel sistema:",
        "optionA": "È sempre determinabile a priori da un’analisi statica del codice del programma eseguito ",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Ha un massimo noto a priori solo se la macchina astratta alloca i record di attivazione dallo heap",
        "optionD": "Può avere un massimo noto a priori solo se il linguaggio L permette ricorsione",
        "optionE": "Non dipende dal programma che si esegue",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L'utilizzo della ricorsione in coda (tail recursion) in una funzione:",
        "optionA": "Utilizza più memoria",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Riduce la possibilità di avere stack overflow",
        "optionD": "Riduce l'efficienza della funzione",
        "optionE": "Richiede rimozione manuale degli stack frame ",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun f[] = (print(\"ab\"); 7.0) | f(x::xs) = (print(\"cd\"); 4.0);</div>",
        "optionA": "‘a list --> int",
        "optionB": "“a --> real",
        "optionC": "‘a record",
        "optionD": "‘a tuple",
        "optionE": "‘a list --> real ",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "<div class='code'>  p = malloc(); <br> q = malloc(); <br> *p = 222; <br> *q = 999; <br> *q = *p / 2; <br> q = p; <br> free(p); </div><br> Utilizzando la tecnica dei tombstones cosa succede alla fine del frammento di codice dato?",
        "optionA": "q punta alla tombstone, p punta alla tombstone",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "*p=999, q punta alla tombstone",
        "optionD": "p punta alla tombstone, *q=111 ",
        "optionE": "q risulta deallocato, *p=222",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "La chiusura (closure) è:",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "espressione, ambiente (expression, environment) dove quest’ultimo ha almeno tutte le variabili nell’espressione unitamente all’indirizzo di ritorno",
        "optionC": "espressione, ambiente (expression, environment) dove quest’ultimo ha alcune delle variabili nell’espressione",
        "optionD": "espressione, ambiente (expression, environment) dove quest’ultimo ha almeno tutte le variabili nell’espressione",
        "optionE": "utilizzata per le call by reference",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Se gli array sono memorizzati per colonne ed short int a[100][100] è un array multidimensionale di interi corti (si assuma che la dimensione di uno short int sia 2 byte) con a[0][0] che ha indirizzo 16640, qual è l’indirizzo di a[5][10]?:",
        "optionA": "18650",
        "optionB": "18394",
        "optionC": "17680",
        "optionD": "16894",
        "optionE": "Nessuna delle altre risposte ",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "<div class='code'>z=1; <br> for i=1 to 1+z by 1 do { <br>  write(i); <br>  z++; <br>  } <br>write(z);</div><br> Usando la \"bounded iteration\" (numerically controlled) indicare cosa viene stampato dal seguente codice",
        "optionA": "1 2 3 4 ... (infinite loop)",
        "optionB": "1 2",
        "optionC": "1 2 3",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "1 1 1",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Polish notation. Indicare il risultato di x – 5 6 7:",
        "optionA": "-37",
        "optionB": "-5",
        "optionC": "23",
        "optionD": "-7",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Call by name",
        "optionA": "Usata raramente al giorno d'oggi",
        "optionB": "Utilizzata in molti linguaggi procedurali",
        "optionC": "Richiede il passaggio dei valori delle variabili sullo stack",
        "optionD": "Ha una definizione semplice",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Qual è l'output del seguente codice: <div class='code'>val m = (List.map(fn x=>x*x))[4, 5, 6]; List.foldr Int.+0 m;</div>",
        "optionA": "15",
        "optionB": "77",
        "optionC": "'a list -> int'",
        "optionD": "NaN",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Un'espressione può essere beta-ridotta ad un unica forma normale",
        "optionA": "Mai",
        "optionB": "Sempre",
        "optionC": "Solo se la riduzione termina",
        "optionD": "Ci possono essere diverse forme normali",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "TextIO.lookahead",
        "optionA": "Legge il carattere successivo ma lo lascia nell'input stream",
        "optionB": "Verifica se c'è un altro carattere nell'input stream",
        "optionC": "error",
        "optionD": "Legge il carattere successivo",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "L'iterazione determinata",
        "optionA": "Non è implementabile in nessun linguaggio",
        "optionB": "Permette di modificare la variabile di controllo durante l'esecuzione del corpo dell'iterazione",
        "optionC": "Non permette di sapere in anticipo quante volte si ripeterà indipendentemente dal corpo del ciclo",
        "optionD": "è presente in C, C++ e Java",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Qual è l'output del seguente codice: <div class='code'>val i=ref 1; while !i<10 do i := !i+1;</div>",
        "optionA": "val i=10",
        "optionB": "val it=()",
        "optionC": "Loop infinito",
        "optionD": "Type error",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In ML <div class='code'>:></div> serve a:",
        "optionA": "nessuna delle altre risposte",
        "optionB": "nasconde i componenti di una lista",
        "optionC": "è usata per definire funzioni polimorfiche",
        "optionD": "nasconde i componenti di una struttura",
        "optionE": "definisce la firma di una struttura",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Un linguaggio di programmazione (come FORTRAN) usa un'allocazione fissa della memoria (at compile time). Questo tipo di linguaggio non può supportare:",
        "optionA": "floating point numbers",
        "optionB": "exceptions",
        "optionC": "variable size arrays",
        "optionD": "nessuna delle precedenti",
        "optionE": "procedures",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Dato il seguente programma in ML, indicare il risultato: <div class='code'>Datatype fruit = Apple | Pear | Grape; isApple x = (x=Apple); isApple (Lemon);</div>",
        "optionA": "nessuna delle altre risposte",
        "optionB": "false",
        "optionC": "undeclared value",
        "optionD": "true",
        "optionE": "type error",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Point reversal viene usato per garbage collection:",
        "optionA": "per evitare di sprecare spazio",
        "optionB": "nessuna delle precedenti",
        "optionC": "nelle implementazioni di python",
        "optionD": "quando non si ha spazio per una search structure",
        "optionE": "per gestire loops nelle strutture puntatore",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "La differenza fra espressione e comandi:",
        "optionA": "Un comando può modificare l'ambiente (locale, non locale o globale) mentre una espressione no",
        "optionB": "Non esistono differenze: sono due nomi diversi per la stessa entità sintattica",
        "optionC": "Nessuna delle altre",
        "optionD": "L'esecuzione di un comando produce un valore(o non termina), mentre la valutazione di una espressione può non produrre valori",
        "optionE": "Le espressioni non possono usare simboli appartenenti ad ambienti non locali",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Il cut=! i Prolog:",
        "optionA": "Ha successo e ferma il backtracking",
        "optionB": "nessuna delle altre",
        "optionC": "esegue il backtracking",
        "optionD": "Chiama una eccezione",
        "optionE": "fallisce e ferma il backtracking",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In ML 4+3.0 genera come risultato:",
        "optionA": "Errore di tipo",
        "optionB": "7.0",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Dipende dall'implementazione",
        "optionE": "7",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Pointer reversal is used in garbage collection:",
        "optionA": "In implementations of Python",
        "optionB": "To avoid wasting space for marking used records",
        "optionC": "To deal with loops in pointer structures",
        "optionD": "When we don't have space for a earch structure",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Memorizzare array in ordine di riga o colonna:",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Conta soltanto quando si usa il caching",
        "optionC": "Viene sempre usato l'ordine per colonna",
        "optionD": "Non conta mai",
        "optionE": "Viene sempre usato l'ordine per riga",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Indicare il risultato di Struct2.x = Struct2.i; Dato il seguente programma ML: <div class='code'>structure Struct1 = struct; val i = 3; type t = int; val x = 4; end; signature SIG1 = sig; val i:int; type t; val x: t; end; structure Struct2:> SIG1 = Struct1;</div>",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "3",
        "optionC": "false",
        "optionD": "type error",
        "optionE": "true",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Un ADT è definito essere un modello matematico di un user-defined type, insieme a tutte le operazioni su quel modo:",
        "optionA": "Struttura",
        "optionB": "Primitiva",
        "optionC": "Assignment",
        "optionD": "Cardinalità",
        "optionE": "Nessuna delle precedenti",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Un linguaggio di programmazione (come FORTRAN) usa una allocazione fissa della memoria (in compilazione). Questo tipo di linguaggio non può supportare:",
        "optionA": "Procedure",
        "optionB": "Eccezioni",
        "optionC": "Ricorsione",
        "optionD": "Nessuna della altre risposte",
        "optionE": "Numeri floating-point",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "In Prolog:",
        "optionA": "Conta l'ordine delle regole e predicati (da sinistra a destra) in una regola",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Conta l'ordine delle regole e predicati (da destra a sinistra) in una regola",
        "optionD": "Conta solo l'ordine delle regole",
        "optionE": "Conta solo l'ordine dei predicati (da destra a sinistra) in una regola",
        "optionF": "",
        "correct": "optionE"
    },
    {
        "question": "Si assuma che A sia un array di lunghezza 40. Trovare il 30simo elemento",
        "optionA": "Array.sub(A,30)",
        "optionB": "Array.sub(A,29)",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "sub(A,29)",
        "optionE": "A[30]",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Un linker",
        "optionA": "Viene usato per l'efficienza",
        "optionB": "Sostituisce indirizzi relativi con indirizzi assoluti",
        "optionC": "Viene utilizzato nei linguaggi interpretati",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "È scritto in linguaggio macchina",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In ML, quale espressione è legale",
        "optionA": "[1.0, 2, 3]",
        "optionB": "fnx:real => x*2",
        "optionC": "\"a\", 1, 2",
        "optionD": "(1, 2, 0)",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Qual è il tipo di SOME[2, 3, 4];",
        "optionA": "a' list option",
        "optionB": "int list option",
        "optionC": "(int*int*int) option",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "int list",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Nel lambda calcolo",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "In un applicazione e1e2, l'insieme delle variabili free è dato dall'unione delle variabili free rispettivamente in e1 e in e2 mentre quello delle variabili bound è dato dall'interesezione delle variabili bound rispettivamente in e1 e in e2",
        "optionC": "L'insieme delle variabili free di un espressione costruita da una variabile (e.g., x) è l'insieme vuoto",
        "optionD": "L'insieme delle variabili bound di un espressione costruita da una variabile (e.g., x) è l'insieme vuoto",
        "optionE": "L'applicazione associa a destra",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Un garbage collector",
        "optionA": "è basato su due fasi logiche: identificazione del garbage e raccolta del garbage",
        "optionB": "Richiede un’implementazione basata sulla tecnica dei 'tombstone'",
        "optionC": "Richiede un’implementazione basata sul meccanismo di 'lock and key'",
        "optionD": "Nessuna della altre risposte",
        "optionE": "Può essere implementato con il meccanismo di 'counting reference', che riesce sempre a identificare la memoria allocata ma non più utilizzata",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Beta-riducendo (λx.x(xy))(λz.zx) si ottiene",
        "optionA": "nessuna delle altre risposte",
        "optionB": "yxx",
        "optionC": "λx.xyy",
        "optionD": "xyx",
        "optionE": "La riduzione non termina",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In Prolog:",
        "optionA": "Conta l'ordine (i) delle regole e (ii) dei predicati (da sinistra a destra) in una regola",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "Non è mai possibile fare backtracking",
        "optionD": "Conta solo l'ordine delle regole",
        "optionE": "Conta solo l'ordine dei predicati (da destra a sinistra) in una regola",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Qual è il tipo della seguente espressione: <div class='code'>fun apply (a, b, 0, H, p) = () | apply (a, b, n, H, p) = (p+1;print(Int.toString(a)));</div>",
        "optionA": "fn: int * 'a * int * b * int -> unit",
        "optionB": "fn: int * 'a * int * (int -> int) * int -> string",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "fn: int * 'a * int * b * int -> int",
        "optionE": "fn: int * 'a * int * a * int -> unit",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Comando",
        "optionA": "Il termine comando viene utilizzato per riferirsi solo a comandi condizionali o iterativi",
        "optionB": "la sua valutazione non ritorna mai un valore",
        "optionC": "non può modifcare lo stato",
        "optionD": "è un entità sintattica la cui valutazione non necessariamente restituisce un valore ma può avere un side effect",
        "optionE": "non è tipico dei linguaggi imperativi",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Le funzioni di ordine superiore sono funzioni che hanno come parametro o come valore di ritorno altre funzioni:",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Non è mai possibile avere come valore di ritorno un'altra funzione",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Le biding policies sono importanti per la valutazione delle funzioni di ordine superiore",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In ML non è possibile avere funzioni di ordine superiore",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Le funzioni di ordine superiore sono funzioni che hanno almeno due parametri",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "il cast è un meccanismo di conversione tra tipi esplicito",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "la coercizione è un meccanismo di conversione tra tipi esplicito",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Un tipo T1 è compatibile con un tipo T2 se il tipo T1 può essere usato in contesti in cui ci si aspetta di trovare oggetti di tipo T2",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In caso di coercizione non è mai possibile convertire tipi che hanno una diversa rappresentazione dei valori",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Nei linguaggi moderni si preferisce il cast alla coercizione",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "La memoria statica è una memoria di sola lettura",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L'entità allocata staticamente risiede in una zona fissa della memoria durante tutta l'esecuzione del programma",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Le variabili globali sono tipici esempi di entità allocate staticamente",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "L'allocazione statica della memoria viene realizzata durante l'esecuzione del programma",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L'allocazione statica della memoria è necessaria per realizzare la ricorsione",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L'environment in un blocco può essere solo locale o globale",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L'environment globale contiene associazioni specifiche solo di un particolare blocco di programma",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Le associazioni dell'environment locale di un blocco vengono create nel momento in cui si entra in un blocco e distrutte quando si esce dal blocco",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Le variabli locali e parametri formali sono parte dell'enviroment locale di un blocco",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Non è mai possibile ereditare associazioni tra nomi ed entità denotabili da altri blocchi",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Nel ciclo fetch-decode-execute, una volta incrementato il Program counter non può più essere modificato da nessun altra istruzione",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Nel ciclo fetch-decode-execute, la fase fetch consiste nell'iterare molte volte l'operazione",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Nella fase fetch del ciclo fetch-decode-execute viene incrementato il Program counter",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Nessun registo viene utilizzato nel ciclo fetch-decode-execute",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Nella fase execute del ciclo fetch-decode-execute possono eventualmente essere caricati altri dati",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "I nomi possono essere predefiniti solo dal linguaggio e mai definiti dall'utente",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Il nome e l'entità che il nome denota sono la stessa cosa",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Uno stesso nome può denotare oggetti diversi in momenti differenti",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Uno stessa entità può avere più di nome",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "I nomi possono essere definiti solo dall'utente e mia predefiniti dal linguaggio",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "I nomi possono essere definiti solo dall'utente e mia predefiniti dal linguaggio",
        "optionA": "true",
        "optionB": "false",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Un comando può modificare l’ambiente (locale, non locale o globale) mentre un’espressione non può",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "L’esecuzione di un comando produce un valore (o non termina), mentre la valutazione di un’espressione può non produrre valori",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Un’espressione è un’entità sintattica che produce un valore o non termina, mentre un comando è un’entità sintattica la cui valutazione non necessariamente restituisce un valore ma può avere side effect",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Non esistono differenze: sono due nomi diverse per la stessa entità sintattica",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Le espressioni non possono usare simboli appartenenti all’ambiente non locale",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In ML, il costrutto ”:>”:",
        "optionA": "È usato per definire funzioni polimorfiche",
        "optionB": "È usato per nascondere le componenti di una struttura che non sono visibili nella signature",
        "optionC": "È usato per specificare l’implementazione della struttura",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "È usato per nascondere le componenti di una lista",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In Prolog, l’operatore is:",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "È l’operatore aritmetico che unifica il primo argomento con il valore aritmetico del secondo argomento",
        "optionC": "È un predicato built-in usato con le stringhe",
        "optionD": "È l’operatore aritmetico che corrisponde esattamente all’uguaglianza aritmetica",
        "optionE": "Non esiste alcun operatore is",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Se gli array sono memorizzati per colonne e int a[200][200] è un array multidimensionale di interi (si assuma che la dimensione di un intero sia 4 byte) con a[0][0] che ha indirizzo 1600, qual è l'indirizzo di a[2][10]? (usare decimale):",
        "optionA": "3240",
        "optionB": "9608",
        "optionC": "3602",
        "optionD": "5608",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Se gli array sono memorizzati per colonne e int a[200][200] è un array multidimensionale di interi (si assuma che la dimensione di un intero sia 4 byte) con a[0][0] che ha indirizzo 1600, qual è l'indirizzo di a[2][10]? (usare decimale):",
        "optionA": "3240",
        "optionB": "9608",
        "optionC": "3602",
        "optionD": "5608",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Il processore. Scegli un'alternativa:",
        "optionA": "ha solo una parte di controllo per la gestione delle istruzioni ma non si occupa della parte operativa (per le operazioni aritmeticologiche)",
        "optionB": "nessuna delle altre risposte",
        "optionC": "ha sia una parte di controllo (per la gestione delle istruzioni) che una operativa (per le operazioni aritmetico-logiche)",
        "optionD": "non contiene al suo interno alcun registro",
        "optionE": "ha solo una parte operativa (per le operazioni aritmetico-logiche) ma non si occupa della parte di controllo (per la gestione delle istruzioni",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "La tecnica di reference counting:",
        "optionA": "nessuna delle altre risposte",
        "optionB": "si basa sull’assunzione che un oggetto non è più in uso quando nessun puntatore punta più a quell’oggetto",
        "optionC": "viene utilizzata per ovviare al problema dei dangling references",
        "optionD": "conta il numero di dangling references",
        "optionE": "inizializza il contatore a 1 nel momento in cui l’oggetto viene distrutto",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "I linguaggi di programmazione solitamente:",
        "optionA": "adottano implementazioni puramente interpretative",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "adottano implementazioni con una componente compilativa e una interpretativa",
        "optionD": "adottano implementazioni basate sulla macchina intermittente MI",
        "optionE": "adottano implementazioni puramente compilative",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "β-riducendo ((λx.xxx)(λy.y))(λz.z) si ottiene:",
        "optionA": "La riduzione non termina",
        "optionB": "λa.ax",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "λz.z",
        "optionE": "xxx",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Le associazioni tra nomi e oggetti/entità denotabili:",
        "optionA": "dichiarate in un blocco interno sono visibili esternamente ma vengono deattivate se ridichiarate nel blocco esterno",
        "optionB": "dichiarate in un blocco esterno sono visibili internamente ma vengono deattivate se ridichiarate nel blocco interno",
        "optionC": "dichiarate in un blocco esterno sono sempre visibili internamente",
        "optionD": "nessuna delle altre risposte",
        "optionE": "dichiarate in un blocco sono visibili nei blocchi fratelli",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In ML, qual è il tipo di <br> <div class='code'>fun f[] = (print(\"Hello!\");7.0)<br>&nbsp;|&nbsp;&nbsp;f[x] = (print(\"world!\");5.0)<br>&nbsp;|&nbsp;&nbsp;f(x::y::xs) = if x=y then (print(\"Hello world!\");3.0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else (print(\"Hello world!\");2.0);</div>",
        "optionA": "nessuna delle altre risposte",
        "optionB": "fn: ’a list -> real",
        "optionC": "fn: ‘’a list -> real",
        "optionD": "fn: ‘’a list -> unit",
        "optionE": "fn: ‘a list -> unit",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Dato il seguente pseudo-codice. Qual è il valore di ritorno di f2 se i parametri sono passati per riferimento?<br><div class='code'>int a = 10;<br>int f1 (int v)<br>{<br>&nbsp;&nbsp;a = a + 2;<br>&nbsp;&nbsp;return v * 3;<br>}<br>int f2()<br>{<br>&nbsp;&nbsp;return f1(a+5)<br>}<br></div>",
        "optionA": "non è possibile passare a+5 per riferimento",
        "optionB": "45",
        "optionC": "dipende dal tipo di scope utilizzato",
        "optionD": "10",
        "optionE": "nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Dato il frammento di programma (espresso in pseudo-codice) riportato di seguito, qual è il valore di ritorno di third(), assumendo scoping statico?<br><div class='code'>int r,s,t;<br>void first(void)</br>{</br>&nbsp;&nbsp;r = 5;</br>&nbsp;&nbsp;s = 9;</br>}</br>void second(void)</br>{</br>&nbsp;&nbsp;int s;</br>&nbsp;&nbsp;first();</br>&nbsp;&nbsp;s = 2;</br>&nbsp;&nbsp;t = 50;</br>}</br>int third(void)</br>{</br>&nbsp;&nbsp;int r;</br>&nbsp;&nbsp;r = 10;</br>&nbsp;&nbsp;s = 20;</br>&nbsp;&nbsp;t = r + s;</br>&nbsp;&nbsp;second();</br>&nbsp;&nbsp;return t - s - r;</br>}</div>",
        "optionA": "31",
        "optionB": "5",
        "optionC": "Non è possible dirlo",
        "optionD": "25",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Il meccanismo di gestione delle eccezioni permette di specificare solo come un’eccezione può essere sollevata",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Il meccanismo di gestione delle eccezioni permette di specificare solo come un’eccezione può essere gestita",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Possono esistere eccezioni anonime",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Il meccanismo di gestione delle eccezioni permette di specificare solo quali eccezioni possono essere gestite",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Un’eccezione è un evento che, controllato durante l’esecuzione di un programma, non deve (o non può) essere gestito nel normale flusso di controllo",
        "optionA": "Vero",
        "optionB": "Falso",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In ML, qual è il risultato di <br><div class='code'>fun comp g = g o op +;<br>fun h y = y * 2;<br>comp h (3,1);<br></div>",
        "optionA": "errore di compilazione",
        "optionB": "7",
        "optionC": "8",
        "optionD": "6",
        "optionE": "5",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "In ML, qual è il risultato di <br><div class='code'>fun comp g = g o op +;<br>fun h y = y * 2;<br>comp h (3,1);<br></div>",
        "optionA": "errore di compilazione",
        "optionB": "7",
        "optionC": "8",
        "optionD": "6",
        "optionE": "5",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "B-riducendo (Ax.x) (Ayyy) (Az.zw) si ottiene",
        "optionA": "ww",
        "optionB": "nessuna delle altre risposte",
        "optionC": "Xa.ax",
        "optionD": "la riduzione non termina",
        "optionE": "ZW",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Dato il seguente pseudo-codice. Qual è il valore di ritorno di g se i parametri sono passati per nome?<div class='code'><br>int j = 10;<br>int f (int x)<br>{<br>    x = 6;<br>    j = 2;<br>    return x/j;<br>}<br>int g()<br>{<br>    int i, k;<br>    i=j/5;<br>    k = f(i);<br>    return i+k;<br>}</div>",
        "optionA": "9",
        "optionB": "5",
        "optionC": "dipende dallo scope",
        "optionD": "0",
        "optionE": "nessuna delle altre",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In ML, qual è il tipo di<br><div class='code'>fun g[] print('nil')<br>Ig (x::xs) g xs;</div>",
        "optionA": "fn: 'a list -> unit",
        "optionB": "fn: ''a list -> unit",
        "optionC": "fn: 'a list -> string",
        "optionD": "fn: ' 'a list -> string",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Un'entità denotabile è",
        "optionA": "Un'entità che può essere memorizzata",
        "optionB": "Un'entità che viene utilizzata come riferimento per un'altra entità",
        "optionC": "Un'entità a cui può essere dato un nome",
        "optionD": "Un'entità che ancora non compare nell'ambiente",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Il type system di un linguaggio",
        "optionA": "include anche la specifica di quando effettuare il controllo dei tipi (se staticamente o dinamicamente)",
        "optionB": "nessuna delle altre risposte",
        "optionC": "è definito esattamente da (i) la definizione dei tipi predefiniti, (ii) i meccanismi per definire nuovi tipi e (iii) i meccanismi di controllo dei tipi (equivalenza, compatibilità e inferenza)",
        "optionD": "è definito solo ai meccanismi di controllo dei tipi, cioè equivalenza, compatibilità e inferenza",
        "optionE": "include solo la definizione dei tipi predefiniti e i meccanismi per definire nuovi tipi",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sulle funzioni di ordine superiore è/sono vera/e?<br>Non è mai possibile avere come valore di ritorno un'altra funzione",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sulle funzioni di ordine superiore è/sono vera/e?<br>Le funzioni di ordine superiore sono funzioni che hanno come parametro o come valore di ritorno altre funzioni",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sulle funzioni di ordine superiore è/sono vera/e?<br>In ML non è possibile avere funzioni di ordine superiore",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sulle funzioni di ordine superiore è/sono vera/e?<br>Le funzioni di ordine superiore sono funzioni che hanno almeno due parametri",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sulle funzioni di ordine superiore è/sono vera/e?<br>Le binding policies sono importanti per la valutazione delle funzioni di ordine superiore",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "La valutazione con corto circuito (o lazy evaluation di espressioni booleane) del predicato 'B1 || B2' (dove || rappresenta un or logico):",
        "optionA": "Stabilisce che se 'B1' è vero, allora 'B2' non viene valutato",
        "optionB": "Stabilisce che se 'B2' è falso, allora 'B1' non viene valutato",
        "optionC": "Crea un non-determinismo nella valutazione di 'B1' e 'B2'",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "Stabilisce che 'B1' e 'B2' devono essere valutati in parallelo",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Qual è la caratteristica principale dell'allocazione della memoria mediante heap?",
        "optionA": "Permette l'allocazione e la deallocazione della memoria a tempo di compilazione",
        "optionB": "Permette l'allocazione e la deallocazione manuale della memoria",
        "optionC": "Permette l'allocazione e la deallocazione della memoria in qualunque momento a runtime",
        "optionD": "Permette l'allocazione e la deallocazione illimitata della memoria",
        "optionE": "Nessuna delle risposte precedenti",
        "optionF": "",
        "correct": "optionC"
    },
    {
        "question": "Data la seguente lambda-expression, quali sono le variabili free? <div class='code'>(Aa. (Ab. bf (c. dc ag)))</div>",
        "optionA": "b",
        "optionB": "Nessuna delle altre risposte",
        "optionC": "a, b, c",
        "optionD": "f",
        "optionE": "d, f, g",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "Dato il frammento di programma (espresso in pseudo-codice) riportato di seguito, qual è il valore di ritorno di f3(), assumendo scoping dinamico?<br><div class='code'>int i, j;<br>void f1(void) {<br>    i = 8; j = 9;<br>}<br>void f2(void) {<br>    int i;<br>    f1();<br>    j = 5;<br>}<br>int f3(void) {<br>    int i, k;<br>    i = 10;<br>    j = 20;<br>    k = i + j;<br>    f2();<br>    return k - j - i;<br>}</div>",
        "optionA": "2",
        "optionB": "0",
        "optionC": "Non è possibile dirlo",
        "optionD": "11",
        "optionE": "Nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Qual è il risultato del seguente frammento di codice in Scala?<br><div class='code'>val numbers = List(1, 2, 3, 4)<br>val s = for (n <- numbers) yield n * n</div>",
        "optionA": "List(1, 4, 9, 16)",
        "optionB": "List(1, 2, 3, 4)",
        "optionC": "Nessuna delle altre alternative",
        "optionD": "149 16",
        "optionE": "(1, 4, 9, 16)",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In caso di frammentazione interna",
        "optionA": "Lo spazio necessario per il blocco da allocare è più grande dello spazio disponibile in memoria",
        "optionB": "I programmi che allocano memoria dinamicamente non funzionano correttamente",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Viene perso spazio utile perchè lo spazio necessario per il blocco da allocare è più piccolo del blocco disponibile in memoria",
        "optionE": "Lo spazio necessario per il blocco da allocare è disponibile in memoria ma non può essere utilizzato",
        "optionF": "",
        "correct": "optionD"
    },
    {
        "question": "I record di attivazione:",
        "optionA": "possono contenere informazioni sulle variabili locali e sui risultati intermedi",
        "optionB": "vengono utilizzati solo per i blocchi e non per le procedure",
        "optionC": "vengono allocati a tempo di compilazione",
        "optionD": "non vengono mai utilizzati in caso di funzioni o procedure ricorsive",
        "optionE": "nessuna delle altre risposte",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In Prolog, cosa restituiscono le seguenti queries (true o false)?<br>?- 8 is 5+3.",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In Prolog, cosa restituiscono le seguenti queries (true o false)?<br>?- 5+1 = 4+2.",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "In Prolog, cosa restituiscono le seguenti queries (true o false)?<br>?- 5+1 is 6.",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In Prolog, cosa restituiscono le seguenti queries (true o false)?<br>?- 5+1 is 4+2.",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "In Prolog, cosa restituiscono le seguenti queries (true o false)?<br>?- 4 = 3+1.",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sui blocchi è/sono vera/e:<br>Un blocco è una sezione di un programma identificata da simboli di apertura e di chiusura (che può contenere dichiarazioni locali a quella parte di codice)",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sui blocchi è/sono vera/e:<br>I blocchi anonimi sono procedure senza parametri",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sui blocchi è/sono vera/e:<br>I blocchi nei linguaggi di programmazione non possono mai essere innestati",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sui blocchi è/sono vera/e:<br>Le parentesi graffe non possono essere utilizzate in nessun linguaggio per delimitare un blocco",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionB"
    },
    {
        "question": "Quale/i delle seguenti affermazioni sui blocchi è/sono vera/e:<br>I blocchi anonimi possono comparire in un qualsiasi punto del programma in cui compare un comando",
        "optionA": "True",
        "optionB": "False",
        "optionC": "",
        "optionD": "",
        "optionE": "",
        "optionF": "",
        "correct": "optionA"
    }
]
